[["index.html", "Introduction to R for Mass Spectrometrists Preface", " Introduction to R for Mass Spectrometrists Jeff Jones, Heath Patterson, Ryan Benz 2023-04-03 Preface Who The Authors Jeff Jones (PhD) | Heath Patterson (PhD) | Ryan Benz (PhD) The Audience The topics covered in this book are detailed towards an absolute beginner in R and possibly to programming in general. They are intended to have little to no surprises, and taken from begging to end, one should be able to extend their towards developing analytically processes for their own research, providing means for others to accomplish analyses and begin to extend their skills with more advanced literature. This book is meant for individuals with no previous knowledge of R, although some experience with data and statistical analysis is recommended. Reading and understanding the chapters and exercises should impart the skills for basic data analysis and prepared you for more advanced concepts and skills. What Covered Goals for the Short Course - Learn basic fundamentals of the R programming language - Learn how to use to the RStudio integrated development environment (IDE) - Learn about tidy data, what it is, and why it’s important for data analysis - Learn basic fundamentals of the tidyverse ecosystem of R packages and how they can be used to streamline the data analysis process - Learn how to make data visualizations using the ggplot2 R package At the end of the course, are you able to. - start-up RStudio and make an RStudio project? - read a formatted text file (e.g. csv file) into R? - understand basic properties about the data (e.g. # rows, cols)? - tell someone what tidy data is and why it’s important? - perform some basic data manipulations and operations on the data? - make a simple plot from the data? Not Covered Not covered are the topics of statistical analysis, probability, regression, machine learning or any other advanced analytical topic. Additionally, this book does not cover constructing R packages, documentation, markdown or any other advanced R programming topic. Why This book serves as the basis for the Introduction to R course offered at the annual conference for the American Society for Mass Spectrometry (ASMS), and was developed by the authors out of the need to create a more permanent, expandable and revisable reference document. This book evolved from a 200+ slide presentation used as instruction materials in the “Getting Started with R” two-day short course. It quickly became evident that the amount of material covered in such a compressed time was both limiting in the topics covered and student retention of verbal instructions. Thus, the development of this tome, to specifically provide both a greater depth in topics covered and a record of the instructors nuanced approach to R. This is intended to be a living document, from which improvements are implemented in the explanations, and topics covered. Comments and suggestions from each instructional iteration are incorporated, additionally any external feedback is greatly appreciated. When Started in 2017 as a series of workshops at the annual ASMS conference drawing between 200 and 300 attendees for three consecutive years. The presenters were offered a formal short course starting in 2020 (a remote COVID year). In 2023 it was decided to convert all the teaching materials into a formal book. Where Online You can find the online version here [link]. In Print You can find a print version at XYZ-Press [link]. In-Person This book and it’s contents are covered at the annual American Society for Mass Spectrometry (ASMS), typically the first week in June the weekend prior to the scientific meeting. How Persistence, sweat, tears, and bookdown, of’course. "],["acknowledgements.html", "Acknowledgements", " Acknowledgements A special thanks to the American Society of Mass Spectrometry for allowing us to provide an annual basic R introductory course. "],["introduction-to-r.html", "Chapter 1 Introduction to R Why choose it? What you can do with it The R Learning Curve Thoughts about learning R and how to code Alternatives 1.1 Schedule", " Chapter 1 Introduction to R Before we get started, this book contains some basic cues to help facilitate your understanding of the current topic. NOTE Some helpful explanatory notes and tips appear as a block quote. SKILLS At the beginning of each chapter there is a section on what you should be able to accomplish at the end. EXERCISES At the end of each chapter there are some exercises that extend what has been covered. SKILLS At the end of this chapter you should be able to: - understand why R is a good choice for data analysis - understand that you have just started the learning curve and all your efforts hence forth are worth it Why choose it? R is a great language for data analysis! - Many programming languages are general purpose (can be used in any domain), e.g. C/C++, Java, Python - R is not a general purpose programming language, it’s a language specifically designed for working with data (that’s what scientists do!) - Because R is geared toward data, its design, structure and continued development is focused on making it easier to work with data - R has become one of the top languages for data science, and it’s popularity and usage continues to grow - For scientists, R is a great tool to learn Fast, nimble, forgiving Lots of specialty tools (CRAN, Github, Bioconductor) What you can do with it Read and plot data construct analysis pipelines prototype new algorithms write packages to share The R Learning Curve The learning curve for R 10+ years ago was difficult as there where fewer R resources, it was less mature with not a lot of interest. Additionally, there were fewer people in the community and data science wasn’t “a thing” yet. Figure 1.1: R learning curve past The R programming language is still challenging but worth it. With the introduction of packages encompassed in the tidyverse there are more high-quality resources, mature utilization with well documented explanations and examples. Currently there is lots of current interest in R with a large community of users and developers. Additionally, the data science “revolution has pushed R to develop and evolve, become more user-centric. Figure 1.2: R learning curve present Thoughts about learning R and how to code The first step to learning a programming language is to learn its syntax (the set of rules and symbols that make up structurally correct code). Computers are really picky, and even the smallest violations of the syntax rules will result in code that doesn’t run (typos, incorrect names, missing spaces or too many spaces, wrong brackets, …). Syntax errors are frustrating, and unfortunately, the most common mistake for beginners. Hang in there, start simple, try to understand very simple cases first, then build and expand on them Alternatives Scripting: Python, Julia, Matlab Python is a great language, and is another top language for data science If you want to become a data scientist or work heavily with data, learning both R and Python is a great idea – both have pros and cons But, if you choose Python over R, that’s not a bad choice either R might work better for some, Python for others If R just isn’t working for you, give Python a shot Complied: C, C++, Java, Rust, etc. Did you know R can use functions from Python, C and Rust 1.1 Schedule Segment Chapters ? Day 1 Morning Intro and Basics Day 1 Afternoon tidyverse (w/ data set) Day 2 Morning ggplots / mass spec-ish Day 2 Afternoon (tidyverse + ggplot) mass spec data "],["installation.html", "Chapter 2 Installation 2.1 R interpreter 2.2 Rstudio 2.3 Packages 2.4 Packages Utilized in This Book", " Chapter 2 Installation In the scope of this book, there are three main components that need to be installed, and periodically updated: The R interpreter - the software that understands math and plotting RStudio IDE - the software that makes it easy write code and visualize data R Packages - bits of R code that perform specalized operations In this book we will be utilizing the RStudio integrated development environment (IDE) to interact with R. Two separate components are required for this - the R interpreter and the RStudio IDE. Both are required as the RStudio IDE only provides an interface for the R interpreter, which reads the code and does all the mathematical operations. The R interpreter can be used alone, interacting through the command line (eg. Windows CMD, MacOS and Linux Terminal), a plain text editor or another IDE such as Xcode, VSCode, Eclipse, Notepad++, etc. Rstudio provides a comprehensive, R specific environment, with auto-complete, code syntax highlighting, in-editor function definitions along with package management and plot visualizations. 2.1 R interpreter The underlying “engine” for R programming language can be downloaded from The R Project for Statistical Computing. R is an open-source implementation of the S statistical computing language originally developed at Bell Laboratories. Both langauges contain a variety of statistical and graphical techniques, however, R has been continually extended by professional, academic and amateur contributors and remains the most active today. With the advent of open-source sharing platforms such as GitHub, R has become increasingly popular among data scientists because of its ease of use and flexibility in handling complex analyses on large datasets. Additionally, one of R’s strengths is the ease with which well-designed publication-quality plots can be produced. Steps Navigate to The R Project Click on CRAN under Download, left-hand side Click on https://cloud.r-project.org/ under 0-Cloud This will take you to the globally nearest up-to-date repository Click on Download for ... and choose the OS compatible with your device Windows OS Click on base MacOS For an Intel CPU: click R-4.x.x.pgk to download For an M1 CPU: click R-4.x.x-arm64.pkg to download After downloading, double-click the installer and follow the instructions Figure 2.1: Mac Installer Linux Click on your distribution and follow the instructions provided. Most of these instructions require knowledge of the Terminal and command line interface for *unix systems. 2.2 Rstudio RStudio, prior to 2023, was an independent software provider for the ever-popular RStudio products, which included both the desktop and server based IDEs, along with the RShiny applications and servers that facilitate easy-to-build interactive web applications straight from R, and deployed on the web. The last chapter in this book will explore the tidyproteomics package which also has a Shiny web application. RStudio announced at the beginning of 2023 a soft pivot to Posit, which essentially is a rebranding of the RStudio company to encompass a larger data science audience, one that also provides integration with the Python programming language inside the RStudio IDE. The most trusted IDE for open source data science “RStudio is an integrated development environment (IDE) for R and Python. It includes a console, syntax-highlighting editor that supports direct code execution, and tools for plotting, history, debugging, and workspace management. RStudio is available in open source and commercial editions and runs on the desktop (Windows, Mac, and Linux).” — www.posit.co (Jan 2023) Steps Navigate to posit.co, alternatively rstudio.com redirects to the Posit website. Click Download RStudio in the menu top right Select RStudio Desktop Click Download RStudio skip 1: Install R Click Download RStudio Desktop for .. Windows OS MacOS Opening the .dmg file shows the archive that can be copied into the Applications folder simply by click-dragging the application onto the Applications folder shortcut. Figure 2.2: RStudio IDE Install Linux 2.2.1 IDE Layout The RStudio Integrated Development Environment (IDE) is a powerful tool that can make your data analysis and coding tasks more manageable. One of the key features of the RStudio IDE is that it consists of four individual panes, each containing parts of the total environment. This makes it easier for you to navigate your coding and analysis tasks. For example, while creating and viewing a plot, you can have the text editor and console open and organized. This way, you can easily see how the code you are writing is impacting the plot you are creating. Having everything in one place can also help reduce the clutter on your desktop, as you don’t need to have multiple applications open at the same time. Overall, the RStudio IDE is an excellent option for anyone looking to streamline their coding and data analysis workflows. By taking advantage of its various features, you can make your work more efficient and enjoyable. Figure 2.3: RStudio IDE in the default layout The Editor Tabs: All Open Files The Editor is a tool that allows you to write R code with ease. It is essentially a text editor, but with the added benefit of having knowledge of R. This means that it can automatically color different parts of your code based on their function. This can be a huge time saver, as it makes it easier to read and understand your code. For example, comments in R code start with a hash (#) symbol. In the Editor, these comments are colored light green, making them easy to spot. Similarly, operators like the plus sign (+) and the assignment operator (&lt;-) are colored light blue. This makes it easy to identify where these operators are being used in your code. Variables are an important part of any programming language, and R is no exception. In the Editor, variables are colored black. This makes it easy to distinguish variable names from other parts of your code. Finally, quoted text (also known as strings) are colored purple. This makes it easy to identify where strings are being used in your code. In summary, the Editor is a powerful tool that can help you write R code more efficiently. By automatically coloring different parts of your code, it makes it easier to read and understand. Whether you are a beginner or an experienced R programmer, the Editor can help you write better code in less time. Figure 2.4: RStudio IDE syntax highlighting The Editor also has the ability to suggest available variables and functions. In the image provided, the editor suggests using the mean() function to calculate the average of a collection of values. A pop-up with a description accompanies the suggestion. This feature occurs after typing in the first three letters of anything, and the editor will try to guess what you want to type next. This is a helpful tool that can save you time and effort when writing R code. Figure 2.5: RStudio IDE auto complete Files and Plots Tabs: Files, Plots, Packages, Viewer, and Presentation When you’re working in RStudio, your workflow is made simple with the various tabs and features available. For instance, the script that you’re currently working on is saved to the current project and can be accessed via the Files tab located on the top right-hand side of the pane. This tab provides an overview of all the files in the working directory, and you can easily navigate between them. If you need to open another file, you can do so by clicking on the File menu or by using the shortcut key. When you open a new file, it will create a new tab in the Editor pane, which allows you to switch between open files. This feature is super helpful when you’re working on multiple files simultaneously. Another useful tab located in the same pane is the Plots tab. This tab provides a quick way to view any active plots instantly. You don’t need to export your plots or save them separately. Instead, you can view them right within RStudio. This is where RStudio truly shines, as it brings together editing and visualization in one application. Figure 2.6: RStudio IDE plot window The Console Tabs: Console, Terminal, and Background Jobs In the RStudio IDE, the Console pane is where lines of code are executed from the editor. It is a vital component of the RStudio interface that allows users to interact with R in real-time. The Console pane is not only where code is run, but it is also where users can view output and error messages. Additionally, the Console pane provides users access to the computer’s terminal. This feature allows users to execute commands outside of the R environment, such as navigating files and directories or installing packages. Overall, the Console pane is an essential tool for any RStudio user and should be utilized to its full potential. Environment Tabs: Environment, History, Connections, and Tutorial When you’re working on a project in R, it’s essential to keep track of the variables and functions that you’re using in your current session. The Environment tab, located at the top left of the RStudio interface, provides a concise summary of in-memory variables and functions that were created locally, as opposed to functions that were loaded from a package. This summary can be useful for new-comers to R because it allows you to quickly see what objects you are currently working with, without having to remember each or manually check. By having a clear overview of your current session, you can avoid mistakes or errors that might arise from using the wrong object or function. Overall, the Environment tab is a helpful feature of RStudio that can save you time and frustration. If you’re new to R or just starting to use RStudio, make sure to keep an eye on the Environment tab and make use of its features as often as possible. As you become more versed in RStudio this tab may become less relevant. Figure 2.7: RStudio IDE environment window 2.2.2 Usage .. Running lines of code in RStudio 2.2.2.1 Run from the editor (recommended) Type in the code in the Editor (top-left pane) Put editor cursor anywhere on that line Press Ctrl/CMD+Enter. Multiple lines: highlight multiple lines then press Ctrl/CMD+Enter #### Run from the onsole (occasionally) Type code into Console (bottom-left) after the ‘&gt;’ Press Enter. Multiple lines, not advised, but copy and paste multiple lines into console then press Enter. 2.3 Packages 2.3.1 What are R Packages? R packages are a powerful tool in the R programming language that allow you to easily use code written by others in your own projects. They can save a lot of time and effort in the development of your own code, as they often provide new functions to deal with specific problems. For example, the popular ggplot2 package provides a variety of functions to help you create beautiful visualizations, while the mzR package allows you to read mass spectrometry data files with ease. Additionally, the twitteR package is a great tool for accessing Twitter data and conducting analysis. 2.3.2 Where to get R Packages It’s worth noting that packages can be written by anyone, which means that their quality can vary widely. While there are many high-quality packages available, it’s important to be wary of randomly coming across packages on the internet. To ensure that you’re working with trustworthy code, it’s a good idea to stick with well-established and frequently updated packages from reputable sources such as the CRAN (The Comprehensive R Archive Network) and Bioconductor repositories. By doing so, you can ensure that your code is reliable, efficient, and secure. CRAN cran.r-project.org Bioconductor bioconductor.org GitHub github.com In addition to using established packages, it’s also possible to create your own packages in R. This is a great way to share your own code with others and make it accessible to a wider audience. When creating a package, it’s important to follow a set of best practices to ensure that your code is well-documented, easy to use, and compatible with other packages. This includes providing clear and concise documentation, including examples and tutorials, and following established coding conventions. Another important consideration when working with R packages is version control. It’s essential to keep track of the versions of the packages you’re using, as updates can sometimes break existing code. By using a tool like Git or GitHub, you can easily manage different versions of your code and keep track of changes over time. This can be especially useful when collaborating with others on a project. Overall, R packages are an essential tool for anyone working with R. By using established packages and following best practices when creating your own, you can ensure that your code is efficient, reliable, and easy to use. And by using version control, you can keep track of changes over time and collaborate effectively with others. 2.3.3 Installing R Packages When working with R, it is important to understand how to install packages. R packages are collections of functions, data, and documentation that extend the capabilities of R. Most R packages have binary versions available for direct installation with no additional steps required. Binary packages are pre-compiled and ready-to-use packages that are platform-specific. They can be installed with the install.packages() function in R. NOTE: Follow the examples below to install all the required packages used in this book. Jump to the following section if you run into any issues. Use the copy-paste button in the top-right of each code block. Installing from CRAN # this installs all of the packages in the tidyverse collection install.packages(&#39;tidyverse&#39;) Installing from Bioconductor # do this once to install the Bioconductor Package Manager install.packages(&quot;BiocManager&quot;) # this installs the mzR package BiocManager::install(c(&quot;mzR&quot;, &quot;xcms&quot;, &quot;MSstats&quot;, &quot;MSnbase&quot;)) Installing from GitHub # do this once to install the devtools package install.packages(&quot;devtools&quot;) # this installs the tidyproteomics package install_github(&quot;jeffsocal/tidyproteomics&quot;) NOTE: There maybe several additional packages to install including additional operating system level installs. Go to the tidyproteomics webpage for additional installation help. 2.3.4 Potential Gotchas However, there are cases where a binary version of a package may not be available. This could be because the package is new or has just been updated. In such cases, the package may need to be compiled before it can be installed. Compiling a package involves converting the source code into machine-readable code that can be executed. To compile R packages, you’ll need to have the necessary programs and libraries installed on your computer. For Windows, you’ll need to install RTools, which provides the necessary tools for package compilation. For Mac, you’ll need to install Command Line Tools. Once these tools are installed, you can use them to compile packages that are not available as binaries. However, it’s worth noting that package compilation can sometimes fail for various reasons. This can be frustrating, especially if you’re new to R. Therefore, it is generally recommended to stick with using binary packages whenever possible. Binary packages are more stable and easier to install, making them the preferred option for most users. In summary, when working with R, it’s important to understand how to install packages. Most packages have binary versions available for direct installation, but there may be cases where you need to compile a package yourself. While package compilation can be useful in some cases, it can also be frustrating and time-consuming. Therefore, it’s generally recommended to stick with using binary packages whenever possible. 2.4 Packages Utilized in This Book 2.4.1 tidyverse The Tidyverse R package is a collection of data manipulation and visualization packages for the R programming language. It includes popular packages such as dplyr, ggplot2, and tidyr, among others. The Tidyverse R package is a powerful and versatile tool for data analysis in R. It includes a collection of data manipulation and visualization packages designed to work seamlessly together, making it easy to analyze and visualize data in R. library(tidyverse) The readr package provides a versatile means of reading data from various formats, such as comma-separated (CSV) and tab-separated (TSV) delimitated flat files. In addition to its versatility, the readr package is also known for its speed and efficiency. It is designed to be faster than the base R functions for reading in data, making it an ideal choice for working with large datasets. tbl &lt;- &quot;./data/table_peptide_fragmnets.csv&quot; %&gt;% read_csv() ## Rows: 14 Columns: 7 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (4): ion, seq, pair, type ## dbl (3): mz, z, pos ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. The tibble package embodies a modern, flexible take on the data table, making it a powerful tool for data analysis in R. This package includes a suite of functions that allow you to easily manipulate and reshape data. It also has a printing method that makes it easy to view and explore data, even when dealing with large datasets. Additionally, tibble objects are designed to work seamlessly with other Tidyverse packages, such as dplyr and tidyr, making it easy to switch between packages and maintain a consistent syntax. print(tbl) ## # A tibble: 14 × 7 ## ion mz z seq pair pos type ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 b1+ 98.1 1 P p01 1 b ## 2 y1+ 148. 1 E p06 1 y ## 3 b2+ 227. 1 PE p02 2 b ## 4 y2+ 263. 1 DE p05 2 y ## 5 b3+ 324. 1 PEP p03 3 b ## 6 y3+ 376. 1 IDE p04 3 y ## 7 MH++ 401. 2 PEPTIDE p00 NA precursor ## 8 b4+ 425. 1 PEPT p04 4 b ## 9 y4+ 477. 1 TIDE p03 4 y ## 10 b5+ 538. 1 PEPTI p05 5 b ## 11 y5+ 574. 1 PTIDE p02 5 y ## 12 b6+ 653. 1 PEPTID p06 6 b ## 13 y6+ 703. 1 EPTIDE p01 6 y ## 14 MH+ 800. 1 PEPTIDE p00 NA precursor The readxl package is a complement to readr providing a means to read Excel files, both legacy .xls and the current xml-based .xlsx. It is capable of reading many different types of data, including dates, times, and various numeric formats. The package also provides options for specifying sheet names, selecting specific columns and rows, and handling missing values. The dplyr package is widely known and used among data scientists and analysts for its interface that allows for easy and efficient data manipulation in tibbles. Providing a set of “verbs” that are designed to solve common tasks in data transformations and summaries, such as filtering, arranging, and summarizing data, all designed to work seamlessly with other Tidyverse packages making it easy to switch between packages and maintain a consistent syntax. One of the key benefits of the dplyr package is its ease of use, making it perfect for beginners and advanced users alike. It is widely used in the R community and is a valuable tool for anyone working with R and data tables. tbl %&gt;% filter(type != &#39;precursor&#39;) %&gt;% group_by(type) %&gt;% summarise( num_ions = n(), avg_mass = mean(mz) ) ## # A tibble: 2 × 3 ## type num_ions avg_mass ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 b 6 378. ## 2 y 6 424. The tidyr package contains a set of data table transformations, including pivotting rows to columns, splitting a single column into multiple ones, and tidying or cleaning up data tables for a more usable structure. These transformations are essential for dealing with real-world data tables, which are often messy and irregular. By using tidyr, you can quickly and easily manipulate data tables to extract the information you need and prepare them for further analysis. tbl %&gt;% filter(type == &#39;precursor&#39;) %&gt;% pivot_wider(z, names_from = &#39;type&#39;, values_from = &#39;mz&#39;) ## # A tibble: 2 × 2 ## z precursor ## &lt;dbl&gt; &lt;dbl&gt; ## 1 2 401. ## 2 1 800. The ggplot2 package stands out as the most advanced and comprehensive package for transforming tabulated data into meaningful and informative graphics. With its wide range of visualization tools, this package allows you to create expressive and compelling graphics that not only look great but also convey detailed information in a clear and concise manner. Apart from other visualization tools, ggplot2 takes a layered approach to creating graphics, allowing for the additive layering of additional data, labels, legends, and annotations, which helps to provide a more comprehensive view of your analysis. tbl %&gt;% mutate(int = rnorm(n(), mean = 1e5, sd=5e4), relative_int = int/max(int) * 100) %&gt;% ggplot(aes(mz, relative_int, color=type)) + geom_segment(aes(xend = mz, yend = 0)) + labs(title = &quot;Simulated MS/MS Spectrum&quot;) One of the key benefits of using the Tidyverse is the standardization of syntax and functions across each package. This means that once you learn the basics of one package, you can easily switch to another package and be confident in your ability to use it. This makes it easier to create reproducible code and improves the efficiency of your data analysis. The Tidyverse is widely used in the R community and is a valuable tool for any data scientist or analyst working with R. It is especially useful for those who need to manipulate and visualize data quickly and efficiently, without sacrificing accuracy. Whether you are new to R or an experienced user, the Tidyverse is a must-have tool in your data analysis toolkit. 2.4.2 Mass Spectrometry Specific Packages This book, while providing a beginners level guide to R programming, also introduces several mass spectrometry-specific packages in many of the code examples. While these examples may only touch on some of their functions, the last chapter is dedicated to a more formal, albeit not comprehensive introduction to many of these packages. For example the mzR package, which enables users to read and process mass spectrometry data, as well as the xcms package, which is used for preprocessing and feature detection. Additionally, the book introduces the MSnbase package, which provides a framework for quantitative and qualitative analysis of mass spectrometry data, and the MSstats package, which is used for statistical analysis of quantitative proteomics experiments. Lastly, the book covers the tidyproteomics package, which provides a collection of tools for analyzing post-analysis quantitative proteomics data using a framework similar to the tidyverse. "],["the-basics.html", "Chapter 3 The Basics 3.1 Reserved Words 3.2 Syntax 3.3 Flow-Control 3.4 Projects Exercises", " Chapter 3 The Basics Welcome to the R Book! In this chapter, we will explore the basics of R, a powerful programming language used for statistical computing and graphics. At its most fundamental level, R is a calculator capable of performing simple, and complex, mathematical operations. It can read and write data to and from files, manipulate the data, calculate summaries and plot visual representations of the data. Essentially, it is a programmatic version of a spreadsheet program. However, R is much more than just a calculator. It is also a platform for conducting complex analyses, statistical evaluations, predictive inferencing, and machine learning. With R, you can explore and visualize data in a variety of ways, perform advanced statistical analyses, and build predictive models. In this chapter, we will start by examining the simplest operations of R. We will cover basic arithmetic, working with variables, and creating basic plots. By the end of this chapter, you will have a solid understanding of the fundamentals of R and be ready to tackle more complex topics. So, let’s get started! At the end of this chapter you should be able to: understand R’s syntax, variables, operators and functions create and edit a project in RStudio 3.1 Reserved Words As we begin our journey, it’s important to keep in mind that there are certain reserved words that carry a special meaning and cannot be used as identifiers. These words have been set aside by the R programming language, and using them as variable names or function names could lead to errors in your code. Therefore, before we dive too deeply into our R programming endeavors, let’s take a moment to familiarize ourselves with these reserved words. This will help us avoid potential issues down the road and ensure that our code runs smoothly. # to read more about them type ?reserved Word Use if, else flow control, part of the if-then-else statement for, repeat, while, break, next flow control, part of the for-loop statement function basis for defining new algorithms TRUE, FALSE Boolean logic values NULL an undefined value Inf , -Inf an infinite value (eg. 1/0 ) NaN ‘not a number’ NA a missing value indicator NOTE: a Null results when a value is missing and could be a string or a numeric, where as a NA results when a known value, such as in a column of numbers, is missing. 3.2 Syntax Welcome to the R Book! Whether you’re just starting out or a seasoned pro, understanding the different components of R code is essential for writing high-quality, efficient R programs. In this section, we’ll take a deep dive into the various components of R code that you should be familiar with. R input is composed of typed characters that represent different parts of a process or mathematical operation. These characters come together to form what we call R code. It’s important to note that R code is not just a random collection of characters - each character serves a specific purpose and contributes to the larger structure of the code. As such, understanding the different components of R code is key to writing effective and efficient R programs. So, what are these different components of R code? Below, we’ve provided some examples to help you get started: 3.2.1 comments # this is an important note 3.2.2 strings \"letters\" or \"numbers\" in quotes 3.2.3 numbers 1 integers or 1.000002 floats 3.2.4 operators +, -, /, *, … 3.2.5 variables var &lt;- 2 containers for information 3.2.6 statements == exactly the same, != not the same 3.2.7 functions add(x, y) complex code in a convenient wrapper By understanding these different components of R code, you’ll be well on your way to writing effective and efficient R programs. So let’s dive in and get started! NOTE The following is a code block, you can copy the code here and paste into RStudio also … R does not have an line ending character such as ; in java, PHP or C++ # adding two numbers here and storing it as a variable four &lt;- 2 + 2 # using the function &#39;cat&#39; to print out my variable along with some text cat(&quot;my number is &quot;, four) ## my number is 4 NOTE the ## at the beginning of the output is only present in the book, you will not see it in your interactions 3.2.1 Comments Comments are essential parts of the code you will write. They help explain why you are taking a certain approach to the problem, either for you to remember at a later time or for a colleague. Comments in other coding languages, including R package development, can become quite expressive, representing parts and structures to a larger documentation effort. Here, however, comments are just simple text that gets ignored by the R interpreter. You can put anything you want in comments. oops, not a comment # This is a comment # and here a comment tag is used to ignore legitimate R code # four &lt;- 2 + 2 four &lt;- 2 * 2 3.2.2 Strings Strings are essentially a sequence of characters, consisting of letters or numbers. They are commonly used in programming languages and are used to represent text-based data. A string can be as simple as a single character, such as “A”, or it can be a longer sequence of characters such as “Hello, World!”. Strings are often used to store data that requires text manipulation, such as usernames, passwords, and email addresses. In contrast to words, which are made up of a specific combination of letters to represent a linguistic term, strings do not follow any specific rules of composition and can be a random or semi-random sequence of characters. # a string can be a word, this is a string variable three &lt;- 1 + 2 # or an abbreviation, this is a variable (thr) representing the string &quot;three&quot; thr &lt;- &quot;three&quot; # a mass spec reference peptide &lt;- &quot;QWERTK&quot; # or an abbreviated variable pep &lt;- &quot;QWERTK&quot; When working with R programming language, it is essential to note that strings play a crucial role in the syntax used. Strings, which define text characters, are used to represent data in R, and they must be enclosed in quotes. Failure to do so will result in the interpreter assuming that you are referring to a variable that is not enclosed in quotes. For instance, in the example above, the peptide variable contains the string of letters representing the peptide amino acid sequence \"QWERTK\". However, it is essential to note that there are no strict rules for how strings and variables are composed, except that variables cannot start with a number. # permitted b4 &lt;- 1 + 3 # not permitted 4b &lt;- 1 + 3. ## Error: unexpected symbol in &quot;4b&quot; There are however, conventions that you can follow when constructing variable names that aid in the readability of the code and convey information about the contents. This is especially useful in long code blocks, or, when the code becomes more complex and divested across several files. For example: # a string containing a peptide sequence str_pep &lt;- &quot;QWERTK&quot; # a data table of m/z values and their identifications tbl_mz_ids &lt;- read_csv(&quot;somefile.csv&quot;) To learn more about and follow specific conventions, explore the following resources: Hadley Wickham’s Style Guide Google’s style Guide The tidyverse style guide 3.2.3 Numbers Numbers are the foundation upon which all data analysis is built. Without numbers, we would not be able to perform calculations, identify patterns, or draw conclusions from our data. In the programming language R, there are two main types of numbers: integers and floats. An integer is a whole number with no decimal places, while a float is a number with decimal places. Understanding the difference between these two types of numbers is essential for accurate numerical analysis. In R, integers are represented as whole numbers, such as 1, 2, 3, and so on, while floats are represented with a decimal point, such as 1.5, 2.75, and so on. It is important to note that integers occupy less space in memory than floats, which can be a consideration when working with large datasets. This means that when possible, it is generally better to use integers over floats in R, as they are more efficient and can improve the overall performance of your code. # integers 1, 12345, -17, 0 Numbers are the foundation upon which all data analysis is built. Without numbers, we would not be able to perform calculations, identify patterns, or draw conclusions from our data. In the programming language R, there are two main types of numbers: integers and floats. An integer is a whole number with no decimal places, while a float is a number with decimal places. In most programming languages, including R, integers are represented as whole numbers, such as 1, 2, 3, and so on, while floats are represented with a decimal point, such as 1.5, 2.75, and so on. It is essential to understand the difference between these two types of numbers for accurate numerical analysis. While integers can only represent whole numbers, floats can represent fractions and decimals. Thus, if you need to represent a number that is not a whole number, you should use a float. Moreover, it is important to note that integers occupy less space in memory than floats. This can be a consideration when working with large datasets, especially when the whole number is enough to represent the data. Therefore, when possible, it is generally better to use integers over floats in R, as they are more efficient and can improve the overall performance of your code. # floats significand &lt;- 12345 exponent &lt;- -3 base &lt;- 10 # 12.345 = 12345 * 10^-3 significand * base ^ exponent 3.2.4 Operators Operators are fundamental components of programming that enable us to manipulate and process various data types. They are symbols that perform a specific action on one or more operands, which could be numeric values, variables, or even strings. Most commonly these symbols allow us to perform basic arithmetic operations such as addition, subtraction, multiplication, and division on numeric values, as well as more complex mathematical operations like exponentiation and modulus. In addition to numeric values, operators can also manipulate string variables. For instance, we can use concatenation operators to join two or more strings together, which is particularly useful when working with text data. By utilizing operators, we can perform powerful operations that allow us to build complex programs and applications that can handle large amounts of data. Operators play a crucial role in programming, as they allow us to manipulate data in a way that would be difficult or impossible to achieve otherwise. NOTE  Remember order of operations (PEMDAS): Parentheses, Exponents, Multiplication and Division (from left to right), Addition and Subtraction (from left to right). At their very basic, operators allow you to perform calculations .. 1 + 2 ## [1] 3 1 / 2 ## [1] 0.5 .. assign values to string variables .. myvar &lt;- 1 .. and compare values. 1 == myvar ## [1] TRUE 2 != myvar + myvar ## [1] FALSE Here is a table summarizing of some common operators in R. Operator Name Description Example &lt;- assignmnet assigns numerics and functions to variables x &lt;- 1 x now has the value of 1 + addition adds two numbers 1 + 2 = 3 - subtraction subtracts two numbers 1 - 2 = -1 * multplication multiplies two numbers 1 * 2 = 2 / division divides two numbers 1 / 2 = 0.5 ^ power or exponent raises one number to the power of the other 1 ^ 2 = 1 = equals also an assignment operator x = 1 x now has the value of 1 == double equals performs a comparison (exactly equal) 1 == 1 = TRUE != not equals performs a negative comparison (not equal) 1 != 2 = TRUE %% modulus provides the remainder after division 5 %% 2 = 1 3.2.5 Variables In programming, variables are essential elements used to store information that can in essence vary. They come in handy when we need to manipulate or retrieve the information stored in them. Variables can be thought of as containers that can store any kind of information, such as letters, words, numbers, or text strings. They are flexible enough to hold different types of data, and we can use them to store all sorts of information. One of the most significant advantages of using variables is that we can refer to them repeatedly to retrieve the information stored in them. We can also manipulate the information stored in them with an operation or replace it with an assignment. Variables are a powerful tool in programming that allows us to store and retrieve information, manipulate it, and perform various operations on it. # create two viables and assign values to each var_a &lt;- 1 var_b &lt;- 3.14 var_a + var_b ## [1] 4.14 R even has some intrinsic variables that come in handy, like pi. pi ## [1] 3.141593 NOTE: in R it is easy to overwrite existing variables, either initalized by R or created by you, causing error and confusion pi &lt;- 9.876543 pi ## [1] 9.876543 3.2.6 Statements Using a comparison operator, you can make logical comparisons called statements. Operator Description Example | an either or comparison, TRUE if both are true FALSE if one is false. 1 == 1 | 1 != 2 = TRUE 1 == 1 | 1 == 2 = FALSE &amp; a comparison where both must be TRUE 1 == 1 &amp; 1 != 2 = TRUE 1 == 1 &amp; 1 != 2 = FALSE NOTE there are also the double operators || and &amp;&amp;, these are intended to work as flow control operators and stop at the first condition met. In the most recent versions of R, the double operators will error out if a vector is applied. 3.2.7 Functions In programming, a function is a type of operator that performs a specific task and can accept additional information or parameters. In fact, all operators are functions in a sense, as they take inputs and produce outputs. The R programming language has a special class of operators called “binary infix” operators. Infix means “in between,” and these operators are placed in between two inputs. These operators have a unique syntax that may confuse beginners, but they are essential for more complex operations in R. Now, you may wonder why we are discussing these esoteric aspects of R in a beginner’s book. The reason is that understanding these unique features of the language can give you a better understanding of what the R programming language is doing, how it is structured, and how you can relate to it. It is important to have a solid foundation in the basics of any language, but gaining a deeper understanding of its more complex elements can help you become a more proficient programmer. So, while binary infix operators may seem like an advanced topic, they are an essential part of the R language and can help you unlock its full potential. 1 + 2 # as an infix operator ## [1] 3 `+`(1,2) # as the function ## [1] 3 sum(1,2) # same result just using a named function ## [1] 3 sum(1,2,3,4,5) # this function however can take in more than 2 values ## [1] 15 We can even create a user defined infix operator … `%zyx%` &lt;- function(a,b) { a + b } 1 %zyx% 2 ## [1] 3 … or just a normal function. zyx &lt;- function(a,b) { a + b } zyx(1,2) ## [1] 3 The notion of an infix operator you and ignore for the most part. But, we will see it again when diving into the tidyverse - a collection of arguably the most powerful data manipulation packages you will encounter. For now, lets move on with more about functions(). 3.3 Flow-Control 3.3.1 If-Else Statements 3.3.2 Loops 3.3.2.1 For 3.3.2.2 While 3.4 Projects Project are how RStudio organizes your work. Think of project as singular goal oriented collection. There are no rules but some basic organizational tips should help simplify your project. 3.4.1 Creating Creating a new project is very forgiving, you can create a new directory with a project name, or create a project out of an existing directory. Either 1. Click on the drop down in the top right 2. OR: Under the menu item select File &gt; New Project In the New Project Wizard select New Directory &gt; New Project, enter the name of the project and click Create Project. Figure 3.1: RStudio Create New Project Figure 3.2: RStudio Create New Project 3.4.2 Editing 3.4.3 Organizing 3.4.3.1 Data 3.4.3.2 Scripts 3.4.3.3 Results 3.4.3.3.1 Tables 3.4.3.3.2 Plots Exercises Calculate the sum of 2 and 3. ## [1] 5 Evaluate if 0.5 is equal to 1 divided by 2. ## [1] TRUE Test if 3 is an even number. Hint, use the modulus operator and a comparison operator. ## [1] FALSE Create a function to test if a value is even resulting in TRUE or FALSE. even(3) ## [1] FALSE Create a function to test or even or odd by returning a string. oddeven(3) ## [1] &quot;odd&quot; "],["data-structures.html", "Chapter 4 Data Structures 4.1 Variable 4.2 Vector 4.3 Matrix 4.4 Data Frame 4.5 List Exercises", " Chapter 4 Data Structures The R programming environment includes four basic types of data structures that increase in complexity: variable, vector, matrix, and list. Additionally there is the data.frame while and independent data structure, it is essentially derived from the matrix. This book introduced variables briefly in 3.2. Here, we will expand on that introduction. At its simplest, a variable can be thought of as a container that holds only a single thing, like a single stick of gum. A vector is an ordered, finite collection of variables, like a pack of gum. A matrix consists of columns of equally-sized vectors, similar to a vending machine for several flavors of gum packs. Mentally, you can think of them as a point, a line, and a square, respectively. Figure 4.1: R main data structures 4.1 Variable Again, a variable is the most basic information container, capable of holding only a single numeric or string value. a &lt;- 1 4.2 Vector A vector is simply a collection of variables of all the same type. In other programming languages these are called arrays, and can be more permissive allowing for different types of values to be stored together. In R this is not permitted, as vectors can only contain either numbers or strings. If a vector contains a single string value, this “spoils” the numbers in the vector, thus making them all strings. # permitted a &lt;- c(1, 2, 3) a ## [1] 1 2 3 # the numerical values of 1 and 3 are lost, and now only represented as strings b &lt;- c(1, &#39;two&#39;, 3) b ## [1] &quot;1&quot; &quot;two&quot; &quot;3&quot; Vectors can be composed through various methods, either by concatenation with the c() function, as seen above, or using the range operator :. Note that the concatenation method allows for the non-sequential construction of variables, while the range operator constructs a vector of all sequential integers between the two values. 1:3 ## [1] 1 2 3 There are also a handful of pre-populated vectors and functions for constructing patters. # all upper case letters LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; # all lower case letters letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; # a repetitive vector of the letter &quot;a&quot; rep(&#39;a&#39;, 5) ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; # a repetitive vector of a previous vector rep(b, 2) ## [1] &quot;1&quot; &quot;two&quot; &quot;3&quot; &quot;1&quot; &quot;two&quot; &quot;3&quot; # a sequence of integers between two values, in this case reverse order seq(10, 5) ## [1] 10 9 8 7 6 5 # same as above 10:5 ## [1] 10 9 8 7 6 5 While variables don’t require a referencing scheme, because they only contain a single value, vectors need to have some kind of referencing sheme, shown in ?? as x[9] and illistrated in the following example. NOTE: the use of an integer vector to sub-select another vector based on position. also … R abides by the 1:N positional referencing, where as other programming languages refer to the first vector or array position as 0. A good topic for a lively discussion with a computer scientist. x &lt;- LETTERS # 3rd letter in the alphabet x[3] ## [1] &quot;C&quot; # the 9th, 10th, 11th and 12th letters in the alphabet x[9:12] ## [1] &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; # the 1st, 5th, 10th letters in the alphabet x[c(1,5,10)] ## [1] &quot;A&quot; &quot;E&quot; &quot;J&quot; Numerical vectors can be operated on simultaneously, using the same conventions as variables, imparting convenient utlity to calculating on collections of values. x &lt;- 1:10 x / 10 ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 In addition, there are facile ways to extract information using a coonditional statement … x &lt;- 1:10 / 10 x &lt; .5 ## [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE … the which() function returns the integer reference positions for the condition x &lt; 0.5 … which(x &lt; .5) ## [1] 1 2 3 4 … and since the output of that function is a vector, we can use it to reference the original vector to extract the elements in the vector that satisfy our condition x &lt; 0.5. x[which(x &lt; .5)] ## [1] 0.1 0.2 0.3 0.4 4.3 Matrix Building upon the vector, a matrix is simply composed of columns of either all numeric or string vectors. That statement is not completely accurate as matrices can be row based, however, if we mentally orient ourselves to column based organizations, then the following data.frame will make sense. Matrices are constructed using a function as shown in the following example. # taking the vector 1:4 and distributing it by 2 rows and 2 columns m &lt;- matrix(1:4,2,2) Elements within the matrix have a reference schema similar to vectors, with the first integer in the square brackets is the row and the second the column [row,col]. ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 Just like a vector, a matrix can be used to compute operations on all elements simultaneously, apply a comparison and extract the variable(s) matching the condition … m_half &lt;- m / 2 w_point5 &lt;- which(m_half &gt; 1) m[w_point5] ## [1] 3 4 … or more sincintly. m[which(m/2 &gt; 1)] ## [1] 3 4 4.4 Data Frame Tables are one of the fundamental data structures encountered in data analysis, and what separates them from matrices is the mixed use of numerics and strings, and the orientation that data.frames are columns of vectors, with a row association. A table can be cinstructed with the data.frame() function as shown in the example. df &lt;- data.frame( let = LETTERS, pos = 1:length(LETTERS) ) ## let pos ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## ... Lets talk about the structure of what just happened in constructing the data.frame table. Note that we defined the column with let and pos referring to letter and position, respectively. Second, note the use of the single = to assign a vector to that column rather than the “out-of-function” assignment operator &lt;- – meaning that functions use the = assignment operator, while data structures use the &lt;- assignment operator. The printed output of the data.frame shows the two column headers and also prints out the row names, in this case the integer value. Now, that this table is organized by column with row assiciations, we can perform an evalutaion on one column and reterive the value(s) in the other. 4.5 List Exercises Construct the following vector and store as a variable. ## [1] &quot;red&quot; &quot;green&quot; &quot;blue&quot; Extract the 2nd element in the variable. ## [1] &quot;green&quot; Construct a numerical vector of length 5, containing the diameters of circles with integer circumferences 1 to 5. Remember PEMDAS. Extract all circumferences greater than 50. ## [1] 50.26549 78.53982 "],["data-tables.html", "Chapter 5 Data Tables 5.1 Tibble, a new Data Structure", " Chapter 5 Data Tables 5.1 Tibble, a new Data Structure –&gt; (08 break, assignment) ## Reading Data into R ## Summarization –&gt; (09 break, assignment) ## Data Manipulation ### dplyr ### tidyr –&gt; (10 break, assignment) "],["data-wrangling.html", "Chapter 6 Data Wrangling 6.1 Tidy Data", " Chapter 6 Data Wrangling 6.1 Tidy Data "],["data-visualization.html", "Chapter 7 Data Visualization 7.1 Base: plot 7.2 GGPlot 7.3 Plotly", " Chapter 7 Data Visualization Visualizing your data is crucial because it helps you understand the patterns, trends, and relationships within the data. A well-designed visualization can make complex data easy to understand and convey insights that would be hard to discern from raw data. Anscombe’s quartet is a classic example that demonstrates the importance of visualizing your data. This quartet comprises four datasets with nearly identical simple descriptive statistics. However, when graphed, they have very different distributions and appear very different from one another. This example shows that relying solely on summary statistics to understand data can be misleading and inadequate. ## # A tibble: 4 × 8 ## # Groups: set [4] ## set mean_x var_x mean_y var_y intercept slope r.squared ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 A 9 11 7.50 4.13 3.00 0.500 0.667 ## 2 B 9 11 7.50 4.13 3.00 0.5 0.666 ## 3 C 9 11 7.5 4.12 3.00 0.500 0.666 ## 4 D 9 11 7.5 4.13 3 0.5 0.666 In data analysis, creating a plot to convey a message or demonstrate a result is a common endpoint. To achieve this, this book utilizes the GGPlot2 package, which is part of the Tidyverse. This package complements the data pipelining demonstrated in the previous chapters, making it a perfect choice for creating a wide range of plots, from simple scatter plots to complex heat maps, making it ideal for data visualization. 7.1 Base: plot R comes standard with the fairly basic plotting function plot(). While this function forms the basis for all plotting interactions in R, it can be greatly extended with additional packages. Two such packages will be explored in this chapter, GGplot2 and Plotly. The former is great for static publication quality plots, of which you will begin to recognize, while the latter provides stunning interactive graphics suitable for web development and Shiny applications. set.seed(1234) plot(sample(1:20),sample(1:20)) set.seed(1234) df &lt;- data.frame( x1 = sample(1:20), y1 = sample(1:20) ) df %&gt;% plot() 7.2 GGPlot library(&#39;tidyverse&#39;) 7.2.1 Syntax The motivation behind GGplot is based on the grammar of graphics such that “the idea that you can build every graph from the same few components” Ideally this accomplishes dual goals of allowing you to quickly construct plots for initial analyses and checking for oddities (as explained above) and following the logical process of the plot construction. To graph in GGPlot there are a few core embodiments that need to be considered. data a table of numeric and/or categorical values data.frame or tibble geom a geometric object or visual representation, that can be layered points, lines, bars, boxs, etc. aesthetics how variables in the data are mapped to visual properties eg. x = col_a, y = col_b coordinate orientation of the data points eg. cartesian (x,y), polar # the basic structure ggplot(data, aes(x,y)) + geom_point() + coord_cartiesian() # combined with dplyr makes for a readable process data %&gt;% ggplot(aes(x,y)) + geom_point() In this example the ggplot() function contains the two components, the data table data and mapping function aes(). Since GGPlot follows a layered modality, the ggplot() function “sets” the canvas and passes the data table data and mapping function aes() to all the functions that follow with the + operator. Lets create some data … set.seed(1234) tbl_mz &lt;- tibble( mz = sample(3500:20000/10, 100), int = sample(1:1e6, 100), ) 7.2.2 Points and Lines tbl_mz %&gt;% ggplot(aes(mz, int)) + geom_point() tbl_mz %&gt;% ggplot(aes(mz, int)) + geom_point() + geom_line() 7.2.3 Bar 7.2.4 Histograms 7.2.5 Density 7.2.6 Segments 7.2.7 Extended Syntax 7.2.7.1 Colors 7.2.7.2 Scales 7.2.7.3 Faceting 7.2.7.4 Labels 7.2.7.5 Annotations 7.2.7.6 Package ggrepel 7.3 Plotly "],["mass-spectrometry-data.html", "Chapter 8 Mass Spectrometry Data 8.1 Commercial 8.2 Open Access Raw Data 8.3 Derived|Processed|Translated Data Outputs", " Chapter 8 Mass Spectrometry Data 8.1 Commercial 8.1.1 RAW (Thermo) 8.1.2 WIFF (Sciex) 8.1.3 D (Agilent) 8.1.4 D (Bruker) 8.2 Open Access Raw Data 8.2.1 mzXML (HUPO) 8.2.2 mzML (HUPO - most common) 8.2.3 mzH5 (HDF5) 8.3 Derived|Processed|Translated Data Outputs 8.3.1 Common Utilities (Proteomics) PD, OpenMS, Skyline, TransPP, MSFragger, MaxQuant Comet, Mascot, XTandem 8.3.2 mzIdent, mzQuant, mzPeptides 8.3.3 MGF (Mascot, Comet) 8.3.4 PIN (Comet) 8.3.5 CSV (Search Engines) "],["mass-spectrometry-r-packages-work-in-progress.html", "Chapter 9 Mass Spectrometry R Packages (work in progress) 9.1 xcms 9.2 MSstats 9.3 MALDIquant 9.4 tidyproteomics", " Chapter 9 Mass Spectrometry R Packages (work in progress) 9.1 xcms 9.2 MSstats 9.3 MALDIquant 9.4 tidyproteomics "],["sharing.html", "Chapter 10 Sharing 10.1 PackRat(?) 10.2 Note Books 10.3 Shiny Apps 10.4 Docker 10.5 GitHub 10.6 Package Development`", " Chapter 10 Sharing This topic covers a wide range of applications towards sharing, weather it is your RStudio project, a distillation of your analysis that others can follow, developing a web based application for others to use, or ways to contain and disseminate reproducible analyses. 10.1 PackRat(?) 10.2 Note Books 10.3 Shiny Apps 10.4 Docker 10.5 GitHub 10.6 Package Development` "]]
